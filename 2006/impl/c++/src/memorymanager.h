#ifndef MEMORYMANAGER_H
#define MEMORYMANAGER_H

#include "um.h"

#include <cstdlib>
#include <iostream>
#include <cstring>
#include <cassert>

#include <vector>

/**
	 @brief Менеджер памяти виртуальной машины.

	 Класс инкапсулирует работу с памятью виртуальной машины. Возможно выделие,
	 удаление и доступ на чтение и запись к массивам
	 дисков виртуальной машины. Кроме того можно копировать один из
	 массивов в памяти машины в так называемый нулевой массив, который содержит
	 программу, выполняющуюся в данный момент. Также можно загрузить нулевой
	 массив напрямую из реального массива целых беззнаковых чисел.

	 Класс обладает возможностью сериализации себя в байтовый поток.

	 @author Виталий Калинкин <lattyf@gmail.com>
*/
class MemoryManager{
    
 public:

	/**
		 Возвращает полностью готовый к работе экземпляр класса. Служит для
		 реализации паттерна Одиночка. При первом вызове создает экзмепляр класса и 
		 в последствии просто возвращает ссылку на него под создания новых.

		 @return Ссылка на инициализированный экземпляр класса.
	*/
	static MemoryManager& get_instance();

	/**
	 * Обеспечивает доступ к произвольной ячейке памяти виртуальной машины.
	 * Параметры при вызове не проверяются. Поскольку оператор возвращает указатель на
	 * массив, то возможен прозрачный доступ к элементам памяти как к двумерному
	 * массиву. Первый индекс (аргумент оператора) указывает номер массива, второй
	 * индекс (первое измерение в возвращенном массиве) указывает номер ячейки в
	 * массиве.
	 * 
	 * @code
	 *	//Обращаемся к 42-му массиву по индексу 17.
	 *	uint a = memory_manager[42][17];
	 * @endcode
	 *
	 * В данном фрагменте кода на самом деле происходит вызов оператора с
	 * аргументом 42, который возвращает ссылку на массив uint. К возвращенному массиву
	 * сразу же применяется оператор [], который и возвращает требуемый элемент.
	 *
	 * @param array_id Индекс массива в оперативной памяти виртуальной машины. При
	 * передаче несуществующего индекса поведение неопределено.
	 * @return Указатель на массив памяти, индекс которого передан в аргументе.
	 * @see uint
	 */
	uint* operator[](int array_id);

	/**
		 Выделяет память под новый массив размером \c capasity. Индекс нового
		 массива будет взят на единицу больше максимального выделенного на данный момент.
		 Если такой индекс будет больше чем максимально допустимое количество массивов,
		 то будет произведен еще одни цикл поиска, начиная индекса 1. Это делается на
		 случай, если на данный момент уже были освобождены некторые из массивов, и можно
		 занять их индекс снова.

		 Если же и при втором цикле поиска не было найдено ни одного допустимого индекса
		 для нового массива, то продолжение работы невозможно, поскольку вся доступная
		 память занята.

		 @param capasity Требуемая ёмкость нового массива.
		 @return Индекс нового массива.
	*/
	uint allocate(uint capasity);

	/**
		 Уничтожает массива с переданным индексом и освобождает память. Индекс после
		 освобождения можно использовать снова. К массиву с таким
		 индексом больше нельзя обращаться.

		 @param array_id Индекс массива для освобождения.
	*/
	void abandon(uint array_id);

	/**
		 Копирует произвольный массив на местно «нулевого» 
		 (хранящего выполняемую в данный момент программу). 
		 Массив с переданным индексом должен существовать.
		 «Нулевой» массив уничтожается, занимаемая им память освобождается.
		 Далее на его место копируется переданный массив.
       
		 @param array_id Индекс массива который будет скопирован на местно
		 «нулевого». Массив должен существовать.
	*/
	void copy_array_to_zero_id(uint array_id);

	/**
		 Напрямую загружает массив целых чисел в «нулевой» массив (хранящий 
		 выполняемую в данный момент программу). 
		 При необходимости «нулевой» массив создается.
       
		 @param scrool Указатель на массив целых чисел для загрузки в «нулевой».
		 @param size Размер массива, переданного в первом параметре.
	*/
	void load_program_from_scroll(uint* scrool, uint size);

	void save_to_stream(std::ostream & stream);
	void load_from_stream(std::istream & stream);

 private:

	uint _next_free_array_id;
	static MemoryManager * _instance;

	std::vector<uint*> _arrays;
	std::vector<bool> _allocated_arrays;
	std::vector<uint> _arrays_capasity;

	MemoryManager(const MemoryManager & );
	MemoryManager();
	uint evaluate_next_free_array_id();
};

#endif
